#!/usr/bin/env python

import sys
import os
import re
import argparse
import json
import string
from collections import namedtuple
from subprocess import check_output, check_call, CalledProcessError
from functools import partial


# Use local binaries to run commands commands in this script.
# Most importantly, use local bower.
base_path = os.path.dirname(os.path.realpath(sys.argv[0]))
local_npm_bin_path = '{base_path}/node_modules/.bin'.format(base_path=base_path)
os.environ['PATH'] = '{bin_path}:{path}'.format(bin_path=local_npm_bin_path, path=os.environ['PATH'])


NODE_MODULES_PATH = 'node_modules'
BOWER_COMPONENTS_PATH = 'app/bower_components'


def die(message):
    print('ERROR: {message}'.format(message=message))
    sys.exit(1)


def npm_package_path(package_name):
    return '{node}/{package_name}'.format(node=NODE_MODULES_PATH, package_name=package_name)


def split_name_and_version(pkg, split_char):
    if split_char not in pkg:
        pkg += '{ch}latest'.format(ch=split_char)
    return pkg.split(split_char)


def is_url(version_or_url):
    return 'git' in version_or_url or 'http' in version_or_url


def semver_to_fixed_version(semver_version):
    if is_url(semver_version):
        return semver_version

    fixed_version_chars = string.digits + '.'
    return ''.join([c for c in semver_version if c in fixed_version_chars])


def npm_install(args):
    # Remove any foreign files in node modules.
    check_call(['git', 'clean', '-fdx', NODE_MODULES_PATH])

    # Fetch the pacakge without running any pre/postinstall (typically build) scripts,
    # and, save the exact version of the module in the package.json file.
    output = check_output(['npm', 'install', args.save, '--save-exact', '--ignore-scripts', '--json', args.name_or_url])
    package_name = json.loads(output)[-1]['name']

    # Commit changes making sure to ignore any .gitignore files in subdirectories of node_modules.
    git_add_cmd = ['git', 'add', '-Af', 'package.json']
    if os.path.isdir(NODE_MODULES_PATH):
        git_add_cmd.append(NODE_MODULES_PATH)
    check_call(git_add_cmd)

    check_output(['git', 'commit', '-m', "(DEP) Install npm package '{package_name}'".format(package_name=package_name)])

    # Now run any pre/postinstall scripts,
    check_call(['npm', 'rebuild'])

    # add any resulting artifacts to the .gitignore file,
    untracked_output = check_output(['git', 'status', '--untracked', '--short', NODE_MODULES_PATH])
    untracked_fnames = [line[3:] for line in untracked_output.splitlines(True)]
    if len(untracked_fnames):
        with open('.gitignore', 'a') as f:
            f.write('# dep: {package_name} - Ignore platform dependent binaries.\n'.format(package_name=package_name))
            f.writelines(untracked_fnames)
            f.write('# enddep: {package_name}\n\n'.format(package_name=package_name))

        # and commit.
        check_call(['git', 'add', '.gitignore'])
        check_output(['git', 'commit', '-m', "(DEP) Ignore binaries from npm package '{package_name}'".format(package_name=package_name)])


def npm_uninstall(args):
    package_name = args.name

    # Remove the package and update package.json
    check_call(['npm', 'uninstall', '--save-dev', package_name])

    # Remove any entries in .gitignore.
    with open('.gitignore', 'r+') as f:
        contents = f.read()

        p = re.compile(r'# dep: {package_name} .*# enddep: {package_name}..'.format(package_name=package_name), re.S)
        contents = p.sub('', contents)

        f.seek(0)
        f.write(contents)
        f.truncate()

    # Commit.
    check_call(['git', 'add', '-A', 'package.json', '.gitignore', NODE_MODULES_PATH])
    check_output(['git', 'commit', '-m', "(DEP) Uninstall npm package '{package_name}'.".format(package_name=package_name)])


def bower_install(args):
    component_name = json.loads(check_output(['bower', 'info', '--json', args.name_or_url]))['name']
    check_call(['bower', 'install', args.save, args.name_or_url])

    # There is no --save-exact flag for bower, so we have to sanitize the bower.json file.
    with open('bower.json', 'r+') as f:
        bower_json = json.loads(f.read())

        if 'resolutions' in bower_json:
            bower_json['resolutions'] = {c: semver_to_fixed_version(v) for c, v in bower_json['resolutions'].iteritems()}

        if 'dependencies' in bower_json:
            bower_json['dependencies'] = {c: semver_to_fixed_version(v) for c, v in bower_json['dependencies'].iteritems()}

        if 'devDependencies' in bower_json:
            bower_json['devDependencies'] = {c: semver_to_fixed_version(v) for c, v in bower_json['devDependencies'].iteritems()}

        f.seek(0)
        f.write(json.dumps(bower_json, indent=4, separators=(',', ': ')))
        f.truncate()

    check_call(['git', 'add', '-Af', 'bower.json', BOWER_COMPONENTS_PATH])
    check_output(['git', 'commit', '-m', "(DEP) Install bower component '{component_name}'".format(component_name=component_name)])


def bower_uninstall(args):
    component_name = args.name

    check_call(['bower', 'uninstall', '--save', component_name])
    check_call(['git', 'add', '-Af', 'bower.json', BOWER_COMPONENTS_PATH])
    check_output(['git', 'commit', '-m', "(DEP) Uninstall bower component '{component_name}'".format(component_name=component_name)])


def _install_dict_of_deps(install_func, deps, save, version_separator):
    assert save in ['--save', '--save-dev']
    assert version_separator in ['@', '#']

    InstallArgs = namedtuple('InstallArgs', ['name_or_url', 'save'])

    for name, version_or_url in deps.iteritems():
        if is_url(version_or_url):
            install_func(InstallArgs(name_or_url=version_or_url, save=save))
        else:
            pkg_str = '{name}{sep}{version}'.format(name=name, sep=version_separator, version=semver_to_fixed_version(version_or_url))
            install_func(InstallArgs(name_or_url=pkg_str, save=save))


def npm_install_dict_of_deps(deps, save):
    _install_dict_of_deps(install_func=npm_install, deps=deps, save=save, version_separator='@')


def bower_install_dict_of_deps(deps, save):
    _install_dict_of_deps(install_func=bower_install, deps=deps, save=save, version_separator='#')


def _read_and_clear_deps(fname):
    Deps = namedtuple('Deps', ['normal', 'dev'])

    normal_deps = None
    dev_deps = None
    with open(fname, 'r+') as f:
        package_json = json.loads(f.read())

        if 'dependencies' in package_json:
            normal_deps = package_json['dependencies']
        if 'devDependencies' in package_json:
            dev_deps = package_json['devDependencies']

        package_json['dependencies'] = {}
        package_json['devDependencies'] = {}

        f.seek(0)
        f.write(json.dumps(package_json, indent=4, separators=(',', ': ')))
        f.truncate()
    return Deps(normal=normal_deps, dev=dev_deps)


def _remove_path_from_gitignore(path):
    with open('.gitignore', 'r+') as f:
        lines = f.readlines()
        filtered_lines = [l for l in lines if path not in l]
        f.seek(0)
        f.writelines(filtered_lines)
        f.write('\n\n')
        f.truncate()


def _add_path_to_gitignore(path):
    with open('.gitignore', 'a') as f:
        f.writelines(['\n\n', path])


def _lock_deps(json_file, install_path, install_func, extra_steps=None):
    deps = _read_and_clear_deps(json_file)
    _remove_path_from_gitignore(install_path)
    if extra_steps is not None:
        extra_steps()

    check_call(['rm', '-rf', install_path])
    check_call(['git', 'add', '-A', '.gitignore', json_file, install_path])
    check_output(['git', 'commit', '-m', '(DEP) Fresh start on {path}.'.format(path=install_path)])

    if deps.normal is not None:
        install_func(deps=deps.normal, save='--save')

    if deps.dev is not None:
        install_func(deps=deps.dev, save='--save-dev')


def lock_project_dependencies(args):
    _lock_deps('package.json', NODE_MODULES_PATH, npm_install_dict_of_deps, extra_steps=partial(_add_path_to_gitignore, '**/.bin'))
    _lock_deps('bower.json', BOWER_COMPONENTS_PATH, bower_install_dict_of_deps)


class Stash:
    _called = False

    _started_clean = False
    _tag = None

    @staticmethod
    def save():
        # Only support calling this method call once per script run.
        assert not Stash._called

        try:
            if len(check_output(['git', 'status', '--short', NODE_MODULES_PATH, BOWER_COMPONENTS_PATH, 'bower.json', 'package.json', '.gitignore'])):
                die("Your working copy contains uncommited changes to {node}, {bower}, bower.json, package.json, or .gitignore. "
                    "It isn't safe to continue.".format(node=NODE_MODULES_PATH, bower=BOWER_COMPONENTS_PATH))

            # If the working dir is clean we don't need to stash, but still need to clean up after we're done.
            if len(check_output(['git', 'status', '--short'])) == 0:
                Stash._started_clean = True
            else:
                Stash._tag = 'DEP-{rand_hash}'.format(rand_hash=os.urandom(8).encode('hex'))
                check_call(['git', 'stash', 'save', '-u', '({tag}) Working directory state.'.format(tag=Stash._tag)])

        except CalledProcessError:
            die("Could not save your working directory state. It isn't safe to continue.")

    @staticmethod
    def pop():
        try:
            if Stash._started_clean:
                # We started clean, leave it clean.
                check_call(['git', 'reset', '--hard'])
                check_call(['git', 'clean', '-fd'])
            else:
                # Safest way to see if we've stashed anything, due to possible race condions
                # (for example, when if the user presses Ctrl+C), is to list the stashes and parse the output.
                stash_output = check_output(['git', 'stash', 'list', "--format='%s'"]).splitlines()
                if len(stash_output) == 0 or not re.match(r'^.*{tag}'.format(tag=Stash._tag), stash_output[0]):
                    return

                # Make sure that we have a clean slate.
                check_call(['git', 'reset', '--hard'])
                check_call(['git', 'clean', '-fd'])

                # Pop back the working tree.
                check_call(['git', 'stash', 'pop', '--index'])

        except CalledProcessError:
            die("We did something terribly wrong. "
                "Check the 'git stash' to see if there are any changes tagged with '{tag}'.".format(tag=Stash._tag))


def get_version():
    with open("{base_path}/package.json".format(base_path=base_path), 'r') as f:
        dep_version = json.loads(f.read())['version']
    bower_version = check_output(['bower', '--version']).strip()
    npm_version = check_output(['npm', '--version']).strip()

    return "pro-dep: {dep}\nbower: {bower}\nnpm: {npm}\n".format(dep=dep_version, bower=bower_version, npm=npm_version)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Safely manage npm and bower dependencies using git.", formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('-v', '--version', action='version', version=get_version())

    subparsers = parser.add_subparsers()

    npm_install_parser = subparsers.add_parser('npm-install', help="Install and commit an npm package.")
    npm_install_parser.add_argument('name_or_url', type=str, help="Name, name@version, or url of the npm package.")
    npm_install_parser.add_argument('--save', action='store_const', const='--save', dest='save', help="This is a normal dependency.")
    npm_install_parser.add_argument('--save-dev', action='store_const', const='--save-dev', dest='save', help="This is a dev only dependency.")
    npm_install_parser.set_defaults(save='--save-dev')
    npm_install_parser.set_defaults(func=npm_install)

    npm_uninstall_parser = subparsers.add_parser('npm-uninstall', help="Uninstall an npm package and commit.")
    npm_uninstall_parser.add_argument('name', type=str, help="Name of the npm package.")
    npm_uninstall_parser.set_defaults(func=npm_uninstall)

    bower_install_parser = subparsers.add_parser('bower-install', help="Install and commit a bower component.")
    bower_install_parser.add_argument('name_or_url', type=str, help="Name, name#version, or url of the bower component.")
    bower_install_parser.add_argument('--save', action='store_const', const='--save', dest='save', help="This is a normal dependency.")
    bower_install_parser.add_argument('--save-dev', action='store_const', const='--save-dev', dest='save', help="This is a dev only dependency.")
    bower_install_parser.set_defaults(save='--save')
    bower_install_parser.set_defaults(func=bower_install)

    bower_uninstall_parser = subparsers.add_parser('bower-uninstall', help="Uninstall a bower component and commit.")
    bower_uninstall_parser.add_argument('name', type=str, help="Name of the bower component.")
    bower_uninstall_parser.set_defaults(func=bower_uninstall)

    lock_project_parser = subparsers.add_parser('lock-project-dependencies',
                                                help="Migrate an existing project to use commited node_modules and bower_components directories.")
    lock_project_parser.set_defaults(func=lock_project_dependencies)

    args = parser.parse_args()

    print(args)

    try:
        Stash.save()
        args.func(args)
    except CalledProcessError:
        die("One of the commands failed, rolling back to where you were.")
    except KeyboardInterrupt:
        print("\nCanceled.")
    finally:
        Stash.pop()
